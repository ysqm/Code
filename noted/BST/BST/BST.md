# BST

> 二叉查找树（Binary Search Tree），（又：二叉搜索树，二叉排序树）它或者是一棵空树，或者是具有下列性质的[二叉树](https://baike.baidu.com/item/二叉树/1602879)： 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 它的左、右子树也分别为[二叉排序树](https://baike.baidu.com/item/二叉排序树/10905079)。二叉搜索树作为一种经典的数据结构，它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。
>
> 摘自百度百科。

总结一下 BST （二叉查找树）的定义：

- 一棵二叉树
- 若存在左子树，则其左儿子的值小于根节点的值。
- 若存在右子树，则其右儿子的值大于根节点的值。
- 若其存在子节点，则其子节点同样满足上述性质。

只看理论的话，这的确是一种很好的结构，查找删除都似乎很快，但是在实际运用中，它却很有问题。

比如插入序列 $1,2,3,4,5,6$ 这种有序序列，BST 就会退化成为一条链，每次操作都几乎是 $\Omicron(n)$ 的，比普通数组还劣。

分析一下，查找或删除操作的最坏时空复杂度都是 $\Omicron(depth)$ ,所以我们如果想个办法使得 BST 的深度维持在 $\log n$ 左右（我们简称其为维护平衡），我们就能借助 BST 的美妙性质来达成均摊 $\Omicron(\log n)$ 级的各种操作了。

而如果我们通过各种神奇的操作维持了 BST 的平衡，那么此时它就是一颗 BT (平衡树)。

根据维护 BST 的性质的方法，我们有许多种 BT ：平衡二叉搜索树（AVL）,树堆(Treap),伸缩树（Splay）......

上述维护 BT 的方法有很多，但用得最多的一种应该就是旋转了，理解了旋转，很多 BT 也就基本理解了，剩下的就是码力上的困难了。

## 关于旋转：

![图片1](%E5%9B%BE%E7%89%871.png)

如上图，从左边这颗树到右边就是 $2$ 号节点左旋，反过来则是 $1$ 号节点右旋。

其中 ABC 都是子树，上面的图片可以很容易看出旋转后得新树仍满足 BST 的性质。

即： $v_a < v_2 < v_c < v_1 < v_b$。

你可以看到，**左旋**就是将根节点的左儿子提到根节点上，根节点改作新根节点的右儿子，而新根节点原本的右儿子则作为原根节点的左儿子。

**右旋**就是**左旋**的反操作。

语言很抽象，但是图片就比较好懂了，看不懂下面的说明，就仔细看一下上图左旋右旋之后的树的区别。

一般在平衡树实现的过程中，我们都会定义一些辅助变量（比如子树大小，子树深度或者干脆一个随机变量），来作维持 BT 的平衡。

此时，我们就可以对通过对辅助变量的判断来旋转来维护 BT 的平衡性了。

当然旋转还有合并的写法，即左旋右旋一起写。

我们仔细观察左旋和右旋改变的节点关系：

我们右旋拟人化的 $2$ 号节点,抽象化一下可以这么说：

与我和父亲关系相反的我的儿子占据了我的位置，我父亲占据了与我和父亲关系相反的我的儿子的位置，我占据了父亲的地位。

这样抽象化一下，我们不难发现右旋也满足上面的描述。

再简略一下：

**反向子代我位，父代反向子位，我代父位。**

这样，我们可以两种旋转操作写在一个函数里。

## Splay

我们先来讲 Splay ，~~因为我先学的就是 Splay~~。

~~这个菜鸡学习的那篇博文代码还有问题，照着打了一版，于是加强版 BT 直接因为查排名暴毙。~~

## Treap

关于 Treap 在旋转操作上与 Splay 并无差别，但维护树平衡的方式不再是 Splay 操作，而是通过将堆与 BST 结合来维护平衡。
下面是严谨的定义：

>树堆，在数据结构中也称Treap，是指有一个随机附加域满足堆的性质的二叉搜索树，其结构相当于以随机数据插入的二叉搜索树。其基本操作的期望时间复杂度为O(logn)。相对于其他的平衡二叉搜索树，Treap的特点是实现简单，且能基本实现随机平衡的结构。
>
> 摘自百度百科。

所以其实 Treap 还是可能会看脸的，如果你的随机数选的好，它能跑的飞快。