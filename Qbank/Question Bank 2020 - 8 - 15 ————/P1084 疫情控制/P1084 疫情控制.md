

## 题目描述

H 国有 $n$个城市，这 $n$ 个城市用 $n-1$ 条双向道路相互连通构成一棵树，$1$ 号城市是首都，也是树中的根节点。

H*H*国的首都爆发了一种危害性极高的传染病。当局为了控制疫情，不让疫情扩散到边境城市（叶子节点所表示的城市），决定动用军队在一些城市建立检查点，使得从首都到边境城市的每一条路径上都至少有一个检查点，边境城市也可以建立检查点。但特别要注意的是，首都是不能建立检查点的。

现在，在 H 国的一些城市中已经驻扎有军队，且一个城市可以驻扎多个军队。一支军队可以在有道路连接的城市间移动，并在除首都以外的任意一个城市建立检查点，且只能在一个城市建立检查点。一支军队经过一条道路从一个城市移动到另一个城市所需要的时间等于道路的长度（单位：小时）。

请问最少需要多少个小时才能控制疫情。注意：不同的军队可以同时移动。

## 输入格式

第一行一个整数 $n$，表示城市个数。

接下来的 $n-1$ 行，每行 3 个整数，$u,v,w$，每两个整数之间用一个空格隔开，表示从城市 u到城市v有一条长为 $w$ 的道路。数据保证输入的是一棵树，且根节点编号为 $1$。

接下来一行一个整数 $m$，表示军队个数。

接下来一行 $m$ 个整数，每两个整数之间用一个空格隔开，分别表示这 $m$ 个军队所驻扎的城市的编号。

## 输出格式

一个整数，表示控制疫情所需要的最少时间。如果无法控制疫情则输出-1。

## 数据范围

$2 \leq m \leq n\leq 5\times10^4,10^9 > w>0$

## 分析：

2020/8/15

思维一点都不难，一眼贪心，尽最大可能往上跳，正确性十分显然，因为往上跳的时候，一定是包含了原来的子树，还可能新增更多的子树，往下跳就会减少，所以显然要往上跳，倍增预处理预定。

第二个点如何找到答案，这一点有点难度，但是可以发现一个性质：

**若在某一时间成功封锁了所有点，那么之后的时间也是一定是被封锁的！**

所以我们可以二分时间，然后判断。

综上，算法伪代码就出现了：

二分一个时间点，判断：

往上跳这个时间点军队所能走的的最长距离（不走到根节点）。

若某个军队走到根的子树时还能剩余的可以走的距离是其到根节点距离的两倍则将其放入闲置组中，剩余路程要减去到根节点的距离，不标记被封锁。

否则标记该节点已被封锁。(本句 update by 2020/8/20-19:30)

当所有军队跳完后，dfs 检查根节点未被封锁的子树节点。

若闲置军队数小于未封锁子树数，则无法封锁。

将未封锁节点按其到根节点的距离降序排序。

将闲置军队按其剩余可走路程降序排序。

然后用贪心的思想匹配未被封锁的子树节点和闲置军队。

存在无法匹配节点则无法封锁。

综上，算法无大问题，但是有一个很恶心东西：

### 它的码量很大！！！！



21：27

伪代码有一个问题：

**若某个军队走到根的子树时还能剩余的可以走的距离是其到根节点距离的两倍则将其放入闲置组中，剩余路程要减去到根节点的距离，不标记被封锁。**

这里少了一种情况，若该子树已被封锁，则就算剩余的可以走的距离不是其到根节点距离的两倍，也可以加入。

22：00

剩余的可以走的距离不论是否是其到根节点距离的两倍都必须全部加入，然后只对未被封锁的子树判断。

加入的还要保存它是从那个子树转移过来的，先把转移出闲置军队的子树给判断能否封锁，在判断别的。